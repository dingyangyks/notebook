# 高性能 javascript 笔记

## 加载和执行

javaScript有阻塞的特性，`<script>`标签会让页面等待脚本的解析和执行。现在诸多浏览器的高版本已经支持`<script>`在下载外部资源是不会阻塞其他`<script>`标签，可以并行下载，但仍会阻塞其他资源的下载， 比如图片。**所以建议`<script>`尽可能的放在` <body>`标签的底部。

### 为了解决`<script>`标签的阻塞性，可以：

* 组织脚本：把多个js文件合并成一个，可以减少性能消耗，文件合并可以通过离线的打包工具

### 无阻塞的脚本

1. **延迟脚本**：`<script>`标签定义了一个扩展属性`defer`，`defer`属性指明本元素所含脚本不会修改DOM，带有`defer`属性的标签可以放在文档任何位置，当解析到该标签时开始下载**但是不会被执行**，它不会阻塞浏览器的其他进程，**它会在DOM加载完成以后，`onload`事件触发之前被执行**
2. **动态脚本**：利用js动态的创建HTML，即可以新创建`<script>`标签，**文件在元素被添加到页面时开始下载，无论何时启动下载，文件的下载和执行不会阻塞页面的其他进程**但需要保证脚本下载且准备就绪，
3. **`XMLHttpRequest`脚本注入**：使用XHR对象来下载js文件，再通过`<script>`标签注入页面，优点：不存在兼容性问题，代码下载后不会自动执行，准备好之后才会执行；局限性：文件必须与所请求的页面处于相同的域。

### 数据存储

数据存储的位置会很大程度上的影响其读取速度

### 四种基本的数据存储位置

1. 字面量：只代表自身，不存储在特定位置。字面量有：字符串，数字，布尔值，对象，数组，函数，正则表达式，null，undefined；
2. 本地变量：用var定义的数据存储单元
3. 数组元素：存储在js数组对象的内部，以数字作为索引
4. 对象成员：存储在js对象对象的内部，以字符串作为索引

### 标示符解析的性能：一个标示符在作用域中位置越深，读写速度就越慢

经验：如果某个跨作用域的值在函数中被引用一次以上，就把他存储在局部变量中。

### 延长作用域链

`with`和``try-catch`可以延长作用域链
`with`会创建一个新的对象变量，并把他的推入作用域链的首位，这意味着函数的局部变量变成了作用域链上第二位，查找局部变量时时间会更长

### 闭包可能导致的性能问题

外部函数的作用域在外部函数执行结束后不会被销毁，而是被保存在了闭包的作用域链上，这就导致了内存的损耗和性能的降低

### 局部变量存在于作用域链的顶端，所以访问起来速度最快

## DOM编程
用脚本进行DOM操作代价昂贵,性能损失较大

### 浏览器中的DOM

文档对象模型(DOM)是一个独立语言的,用于操作XML和HTML文档的程序接口.在浏览器中主要和HTML文档交互.虽然DOM和语言无关,但是DOM接口在浏览器中是用js实现的.浏览器会把DOM和js**独立实现**.

### DOM的访问和修改

访问DOM元素是有代价的,修改元素代价更为昂贵,因为修改会导致浏览器重新计算页面的几何变化.

```js
function innerHtmlLoop1 () {
    for(var count = 0;count < 15000;count++){
        document.getElementById('here').innerHTML += 'a';
    }
}
```
这段代码每次循环迭代,**都会被访问两次,一次读取`innerHTML`,一次重写它的值**

```js
function innerHtmlLoop2 () {
    var content = '';
    for(var count = 0;count < 15000;count++){
        content += 'a';
    }
    document.getElementById('here').innerHTML += content;
}
```
修改后的代码运行更快,**结果显而易见,DOM访问次数越多,代码运行越慢**,因此通用的经验法则是**减少DOM的访问次数,把运算量尽量留在js这一端处理** 

### `innerHTML`对比DOM方法

修改页面的两种方法:`innerHTML`和`document.createElement()`两种方法在性能上相差无几,应该根据**可读性,稳定性,团队习惯,代码风格**来综合决定.

### 节点克隆

DOM中更新页面的另一个途径是克隆已有元素,使用`element.cloneNode()`,在大多数浏览器中,节点克隆都更有效率,但也不是特别明显.

### HTML集合

HTML集合是包含了DOM节点引用的类数组对象,以下方法和属性返回就是一个集合:
```js
document.getElementsByClassName();
document.getElementsByName();
document.getElementsByTagName();
document.images;
document.links;
document.forms;
document.forms[0].elements
```
HTML集合对象是个类数组列表,并不是真正的数组,没有数组的方法,但提供了`length`属性,并且还能以数字索引的方式访问列表中的元素,HTML集合是**假定实时状态**实时存在的,这就意味着**当底层文档对象更新时,HTML集合也会自动更新**  
事实上,**HTML集合一直与文档保持着联系,每次你需要最新信息时,都会重复执行查询过程,即便是访问`length`属性,这正是DOM低效之源**

在循环中,**不推荐在条件控制语句中读取数组的`length`属性,读取一个集合的`length`比读取数组的`length`要慢的多,因为每次都要更新`length`属性,`length`属性的更新会影响循环**

```js
for(var i = 0; i < htmlAggregate.length; i++) {
    /*操作*/
}

for(var i = 0; i < arr.length; i++) {
    /*操作*/
}
```

优化方法:提前缓存`length`属性

```js
for(var i = 0,len = arr.length; i　< len; i++) {
    /*操作*/
}
```

很多情况下如果遍历一个较小的数组,那么缓存`length`就够了,但是由于遍历数组比遍历集合快,因此如果**先将集合拷贝到数组中**,访问属性会更快,但是这是额外的步骤,而且会多遍历一次数组.所有应当评估在特定的条件下使用数组拷贝是否有帮助,

对于一个循环,如果要在循环内部访问集合元素,除了上面的优化方法,为了优化性能,**把当前集合元素储存到一个变量中**,下面这个写法运行最快

```js
var coll = document.getElementsByClassName('item');
var len = coll.length;
var el = null;
for(var i = 0, i　< len; i++) {
    el = coll[i];
    el.style.color = '#aaa';
}
```

### 遍历DOM

`childNodes`是个元素的集合,也需要注意`length`的处理.`childNode`,`nextSibling`,`firstChild`等不会区别元素节点和其他类型的节点(注释和文本节点)  
能区别元素节点和其他节点的DOM的属性
| 属性名                    | 被替代的属性           |
|--------------------------| --------------------:| 
|`children`                | `childNodes`         | 
|`childElementCount`       | `childNodes.length`  |
|`firstElementChild`       | `firstChild`         |
|`lastElementChild`        | `flastChild`         |      
|`nextElementSibing`       | `nextSibling`        | 
|`previouosElementSibing`  | `previousSibling `   |

`children`替代`childNodes`会更快,因为集合项更少,**不包含空白文本节点**

#### 选择器API

`querySelectAll()`:原生的DOM方法,这个方法返回一个`NodeList`,包含匹配节点的类数组对象,这个方法不会返回**HTML集合**,因此返回的节点不会对应实时的文档结构.**这就避免了HTML集合带来的性能问题**

### 重绘和重排

**DOM树**:表面的页面结构
**渲染树**:表示DOM节点如何显示

DOM树中每一个需要显示的节点在渲染树中至少存在一个对应的节点(隐藏的DOM元素在渲染树中没有对应的节点),一旦DOM和渲染树构建完成,浏览器就开始绘制页面元素

当DOM的变化影响了元素的几何属性,比如改变宽高,浏览器需要重新计算元素的几何属性,同样其他元素的集合属性也会因此受到影响,浏览器会让渲染树受到影响的部分失效,并重新构建渲染树,这个过程称为**重排**.完成重排后,浏览器会重新绘制受到影响的部分到屏幕中,这个过程称为**重绘**

### 重排何时发生

当页面布局和几何属性放生变化的时候就需要重排,以下情况会发生重排:
* 添加或者删除可见元素
* 元素位置发生改变
* 元素尺寸发生改变
* 内容改变(文本改变或改变不同尺寸的图片)
* 页面渲染初始化
* 浏览器窗口发生尺寸变化
* 有些改变会出发整个页面的重排,例如当滚动条出现时

### 渲染树变化的排队与刷新

由于每次重排都会产生计算消耗,大多数浏览器通过队列变化修改并批量执行来优化重排过程.然而经常会(不知不觉)强制刷新队列并要求计划任务立即执行,获取布局信息的操作会导致队列刷新,比如以下方法,都需要返回最新的布局信息,
* `offsetTop`,`offsetLeft`,`offsetWidth`,`offsetHeight`
* `scrollTop`,`scrollLeft`,`scrollWidth`,`scrollHeight`
* `clientTop`,`clientLeft`,`clientWidth`,`clientHeight`
* `getComputedStyle()`(`currentStyle` in IE)

### 最小化重绘和重排

减少重绘和重排,应该合并多次对DOM样式的修改,然后一并处理掉

```js
el.style.padding = '5px';
el.style.margin = '5px';
el.style.width = '5px';
//在老版本浏览器会触发三次重排,现代浏览器做了优化,只触发一次

//更有效率的方式:使用cssText,注意会重写样式
el.style.cssText = 'padding:5px; margin:5px; width:5px';

//如果想保留原有样式
el.style.cssText += '; padding:5px;margin:5px;width:5px';
```
另一中批量修改样式的方法是修改css的`class`名,而不是修改内联样式.

### 批量修改DOM

当对DOM元素进行一系列操作时,可以通过一下是**步骤**来减少重绘和重排的次数

1. 是元素脱离文档流
2. 对其应用多重改变
3. 把元素带回文档中
第一步和第三步会出发两次重排,如果忽略这两步,那么第二步中的任何修改都会触发一次重排

使DOM脱离文档流的三种方法:
* 隐藏元素,应用修改,显示元素(`display`)
* 使用文档片段(`document.createDocumentFragment()`),在当前DOM之外创建一个子树,再把它拷贝到文档
* 将原始元素拷贝到一个脱离文档的节点中,修改副本,完成后替换原始元素

### 缓存布局信息

尽量减少布局信息的获取次数,获取后把他赋值给局部变量,然后在操作局部变量

```js
//低效的
elem.style.left = 1 + elem.offsetLeft + 'px';
//高效的
var current = elem.offsetLeft;
current++;
elem.style.left = current + 'px';
```

### 事件委托

利用事件逐层冒泡到父级元素,给父级元素绑定一个处理器,就可以处理子元素上触发的所有事件


## 算法和流程控制

* **`for`循环**:初始化,前测条件,后执行体,循环体,**for循环初始化中`var`语句会创建一个函数级别的变量,而不是循环级,因为js中只有函数级作用域,因此在for循环中定义一个变量相当于在循环体外定义一个新变量**

* **`while`循环**:while循环是前测循环,循环体运行前先计算前测条件,任何for循环都可改写成while循环

* **`do-while`循环**:js中唯一的后测循环,循环体至少执行一次,再由后测条件决定是否再次运行

* **for-in`循环**:可以枚举任何对象的属性名所返回的属性包括从原型链中继承的,循环速度明显要慢,不要用for-in循环来遍历数组对象

除了上面说的提前缓存`length`属性来优化性能外还可以采用**倒序循环**,倒序查询也可以减少属性查找
```js
for(var i = items.length; i--;){
    //操作
}
```

倒序循环中,每个控制条件只需要简单的跟0比较,每次循环从两次比较减少到了一次

### 减少迭代次数

### 优化if-else

* 把最可能出现的条件放在首位
* 把if-else组织成一系列嵌套的if-else语句
* 查找表,把整个结构用数组代替 不用书写任何条件判断语句,即使候选值数量增加时,也几乎不产生额外的性能开销

### 递归

js引擎支持的递归数量与js调用栈大小直接相关,当遇到调用栈大小限制时,应该先检查代码中的递归实例,大多数调用栈错误都是终止条件错误,或者是算法中包含了太多层的递归.

### 迭代

任何递归能实现的代码同样能用迭代来实现,迭代算法通常包含几个不同的循环,优化后的循环比反复调用一个函数的开销要少的多

## 字符串(没有正则表达式)

### 字符串链接

构建字符串的常用方法:**通过一个循环**

### `+`和`+=`操作符

例:`str += "one" + "two";`
此代码运行时会经历四个步骤:
1. 在内存中创建一个临时字符串
2. 在连接后的字符串`"onetwo"`被赋值给该临时字符串
3. 临时字符串与`str`当前的值连接
4. 结果赋给`str`

如果把上面的例子改成如下,就避免了产生临时字符串,这样在大多数浏览器中,性能会提速10%-40%

```js
str += "one";
str += "two";
```

一行代码也可以做到性能提升:`str =  str + "one" + "two";`

### 数组项合并

可以使用`Array.prototype.join`和`Array.prototype.concat`,大多数浏览器在合并数组项的时候都要比字符串连接更慢.

## 快速响应用户界面

### UI线程





 


















